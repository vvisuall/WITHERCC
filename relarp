-- relarp
getgenv().wzmh = {
    Aimbot = {
        Prediction = {
            Amount = 0.1,
            Auto_Prediction = false
        },
        Camera = {
            Smoothing = 1
        },
        Target_Part = "UpperTorso",
        Jump_Offset = -1.5,
        Auto_Air = {
            Enabled = false,
            Delay = {
                Enabled = false,
                Delay_Amount = 0.22
            }
        },
        Resolver = {
            Enabled = false,
            Method = "Calculate"
        }
    },
    Macro = {
        Enabled = false
    },
    Visuals = {
        FOV = {
            Enabled = false,
            Radius = 120,
            Color = Color3.fromRGB(10, 10, 10),
            Transparency = 1
        },
        Highlight = {
            Enabled = false,
            Fill_Color = Color3.fromRGB(255, 255, 255),
            Outline_Color = Color3.fromRGB(0, 0, 0),
            Fill_Transparency = 0.5,
            Outline_Transparency = 0
        }
    }
}

if (not getgenv().wzmh.Loaded) then

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Mc4121ban/Linoria-Library-Mobile/refs/heads/main/Gui%20Lib%20%5BLibrary%5D"))()
local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Mc4121ban/Linoria-Library-Mobile/refs/heads/main/Gui%20Lib%20%5BThemeManager%5D"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Mc4121ban/Linoria-Library-Mobile/refs/heads/main/Gui%20Lib%20%5BSaveManager%5D"))()

local Window = Library:CreateWindow({
   Title = 'Relarp.cc',
   Center = true,
   AutoShow = true,
   TabPadding = 8,
   MenuFadeTime = 0.2
})

local Tabs = {
   Main = Window:AddTab('Main'),
   ['UI Settings'] = Window:AddTab('UI Settings'),
}

local Config = Tabs.Main:AddLeftGroupbox('Config')

Config:AddInput('Prediction', {
   Default = tostring(getgenv().wzmh.Aimbot.Prediction.Amount),
   Numeric = false,
   Finished = false,
   Text = 'Prediction',
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Prediction.Amount = tonumber(Value)
   end
})

Config:AddToggle('Auto Prediction', {
   Text = 'Auto Prediction',
   Default = getgenv().wzmh.Aimbot.Prediction.Auto_Prediction,
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Prediction.Auto_Prediction = Value
   end
})

Config:AddInput('Smoothness', {
   Default = tostring(getgenv().wzmh.Aimbot.Camera.Smoothing),
   Numeric = false,
   Finished = false,
   Text = 'Smoothing',
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Camera.Smoothing = tonumber(Value)
   end
})

Config:AddDropdown('Target Part', {
   Values = { "Head","UpperTorso","HumanoidRootPart","LowerTorso","LeftHand","RightHand","LeftLowerArm","RightLowerArm","LeftUpperArm","RightUpperArm","LeftFoot","LeftLowerLeg","LeftUpperLeg","RightLowerLeg","RightFoot","RightUpperLeg" },
   Default = getgenv().wzmh.Aimbot.Target_Part,
   Multi = false,
   Text = 'Target Part',
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Target_Part = Value
   end
})

Config:AddInput('Jump Offset', {
   Default = tostring(getgenv().wzmh.Aimbot.Jump_Offset),
   Numeric = false,
   Finished = false,
   Text = 'Jump Offset',
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Jump_Offset = tonumber(Value)
   end
})

Config:AddToggle('Auto Air', {
   Text = 'Auto Air',
   Default = getgenv().wzmh.Aimbot.Auto_Air.Enabled,
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Auto_Air.Enabled = Value
   end
})

Config:AddToggle('Air Delay Enabled', {
   Text = 'Air Delay Enabled',
   Default = getgenv().wzmh.Aimbot.Auto_Air.Delay.Enabled,
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Auto_Air.Delay.Enabled = Value
   end
})

Config:AddInput('Air Delay', {
   Default = tostring(getgenv().wzmh.Aimbot.Auto_Air.Delay.Delay_Amount),
   Numeric = false,
   Finished = false,
   Text = 'Air Delay',
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Auto_Air.Delay.Delay_Amount = tonumber(Value)
   end
})

Config:AddToggle('Resolver Enabled', {
   Text = 'Resolver',
   Default = getgenv().wzmh.Aimbot.Resolver.Enabled,
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Resolver.Enabled = Value
   end
})

Config:AddDropdown('Resolver Method', {
   Values = { "Calculate", },
   Default = getgenv().wzmh.Aimbot.Resolver.Method,
   Multi = false,
   Text = 'Resolver Method',
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Aimbot.Resolver.Method = Value
   end
})

local Visuals = Tabs.Main:AddRightGroupbox('Visuals')

Visuals:AddToggle('FOV Enabled', {
   Text = 'Show FOV',
   Default = getgenv().wzmh.Visuals.FOV.Enabled,
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Visuals.FOV.Enabled = Value
   end
})

Visuals:AddInput('FOV Radius', {
   Text = 'FOV Radius',
   Default = tostring(getgenv().wzmh.Visuals.FOV.Radius),
   Numeric = false,
   Finished = false,
   Callback = function(Value)
       getgenv().wzmh.Visuals.FOV.Radius = tonumber(Value)
   end
})

Visuals:AddInput('FOV Transparency', {
   Text = 'FOV Transparency',
   Default = tostring(getgenv().wzmh.Visuals.FOV.Transparency),
   Numeric = false,
   Finished = false,
   Callback = function(Value)
       getgenv().wzmh.Visuals.FOV.Transparency = tonumber(Value)
   end
})

Visuals:AddLabel('FOV Color'):AddColorPicker('FOVColor', {
   Default = getgenv().wzmh.Visuals.FOV.Color,
   Title = 'FOV Color',
   Callback = function(Value)
       getgenv().wzmh.Visuals.FOV.Color = Value
   end
})

Visuals:AddToggle('Highlight Enabled', {
   Text = 'Highlight',
   Default = getgenv().wzmh.Visuals.Highlight.Enabled,
   Tooltip = '',
   Callback = function(Value)
       getgenv().wzmh.Visuals.Highlight.Enabled = Value
   end
})

Visuals:AddLabel('Highlight Fill Color'):AddColorPicker('HighlightFill', {
   Default = getgenv().wzmh.Visuals.Highlight.Fill_Color,
   Title = 'Highlight Fill Color',
   Callback = function(Value)
       getgenv().wzmh.Visuals.Highlight.Fill_Color = Value
   end
})

Visuals:AddInput('Highlight Fill Transparency', {
   Text = 'Fill Transparency',
   Default = tostring(getgenv().wzmh.Visuals.Highlight.Fill_Transparency),
   Numeric = false,
   Finished = false,
   Callback = function(Value)
       getgenv().wzmh.Visuals.Highlight.Fill_Transparency = tonumber(Value)
   end
})

Visuals:AddLabel('Highlight Outline Color'):AddColorPicker('HighlightOutline', {
   Default = getgenv().wzmh.Visuals.Highlight.Outline_Color,
   Title = 'Highlight Outline Color',
   Callback = function(Value)
       getgenv().wzmh.Visuals.Highlight.Outline_Color = Value
   end
})

Visuals:AddInput('Highlight Outline Transparency', {
   Text = 'Outline Transparency',
   Default = tostring(getgenv().wzmh.Visuals.Highlight.Outline_Transparency),
   Numeric = false,
   Finished = false,
   Callback = function(Value)
       getgenv().wzmh.Visuals.Highlight.Outline_Transparency = tonumber(Value)
   end
})

Library:OnUnload(function()
   print('Unloaded!')
   Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
ThemeManager:SetFolder('Ethyl/configs')
SaveManager:SetFolder('Ethyl/configs')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/zaz22real/wzmh.bypasser/refs/heads/main/wzmhbypasser"))()
    local Arguments = loadstring(game:HttpGet("https://raw.githubusercontent.com/wzmh/Ethyl/refs/heads/main/Arguments"))()

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local TweenService = game:GetService("TweenService")
    local CoreGui = game:GetService("CoreGui")
    local Players = game:GetService("Players")
    local Client = Players.LocalPlayer
    local Camera = workspace.CurrentCamera
    local Lighting = game:GetService("Lighting")
    local Locking = false
    local Plr = nil
    setfpscap(9999)
    local PlayerData = {}
    local RemoteArgs = {
        Remote = nil,
        Args = nil
    }

    local wzmhGui = Instance.new("ScreenGui")
    local LockButton = Instance.new("ImageButton")
    local MacroButton = Instance.new("ImageButton")

    wzmhGui.Name = "wzmh (CoreGui)"
    wzmhGui.Parent = CoreGui
    wzmhGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    wzmhGui.ResetOnSpawn = false

    LockButton.Parent = wzmhGui
    LockButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    LockButton.BackgroundTransparency = 1.000
    LockButton.Position = UDim2.new(0.7, 0, 0.75, 0)
    LockButton.Size = UDim2.new(0, 90, 0, 90)
    LockButton.Image = "rbxasset://textures/ui/mouseLock_off@2x.png"
    LockButton.Visible = UserInputService.TouchEnabled or true

    MacroButton.Parent = wzmhGui
    MacroButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    MacroButton.BackgroundTransparency = 1.000
    MacroButton.Position = UDim2.new(0.85, 0, 0.75, 0)
    MacroButton.Size = UDim2.new(0, 90, 0, 90)
    MacroButton.Image = "rbxassetid://8073107221"
    MacroButton.Visible = (UserInputService.TouchEnabled or true) and getgenv().wzmh.Macro.Enabled

    local Highlight = Instance.new("Highlight")
    Highlight.FillColor = getgenv().wzmh.Visuals.Highlight.Fill_Color
    Highlight.OutlineColor = getgenv().wzmh.Visuals.Highlight.Outline_Color
    Highlight.FillTransparency = getgenv().wzmh.Visuals.Highlight.Fill_Transparency
    Highlight.OutlineTransparency = getgenv().wzmh.Visuals.Highlight.Outline_Transparency
    Highlight.Parent = game.CoreGui

    local FOVCircle = Drawing.new("Circle")
    FOVCircle.Transparency = getgenv().wzmh.Visuals.FOV.Transparency
    FOVCircle.Thickness = 0.8
    FOVCircle.NumSides = 100
    FOVCircle.Color = getgenv().wzmh.Visuals.FOV.Color
    FOVCircle.Filled = false

    local make_draggable = function(topbarobject, object)
        local Dragging = nil
        local DragInput = nil
        local DragStart = nil
        local StartPosition = nil
        
        local function Update(input)
            local Delta = input.Position - DragStart
            local pos = UDim2.new(StartPosition.X.Scale, StartPosition.X.Offset + Delta.X, StartPosition.Y.Scale, StartPosition.Y.Offset + Delta.Y)
            local Tween = TweenService:Create(object, TweenInfo.new(0.15), {Position = pos})
            Tween:Play()
        end
        
        if topbarobject then
            topbarobject.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    Dragging = true
                    DragStart = input.Position
                    StartPosition = object.Position
                    
                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then
                            Dragging = false
                        end
                    end)
                end
            end)
            
            topbarobject.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                    DragInput = input
                end
            end)
            
            UserInputService.InputChanged:Connect(function(input)
                if input == DragInput and Dragging then
                    Update(input)
                end
            end)
        end
    end

    local calculate_velocity = function(player)
        if not player or not player.Character then return Vector3.new(0, 0, 0) end
        local primary_part = player.Character:FindFirstChild(getgenv().wzmh.Aimbot.Target_Part)
        if not primary_part then return Vector3.new(0, 0, 0) end
        
        if not PlayerData[player] then
            PlayerData[player] = {
                PreviousPosition = primary_part.Position,
                Velocity = Vector3.new(0, 0, 0)
            }
        end
        
        local current_position = primary_part.Position
        local previous_position = PlayerData[player].PreviousPosition
        local displacement = current_position - previous_position
        local delta_time = RunService.Heartbeat:Wait()
        local velocity = displacement / delta_time
        
        PlayerData[player].Velocity = velocity
        PlayerData[player].PreviousPosition = current_position
        
        return velocity
    end

    local resolve_velocity = function(player)
    if not player or not player.Character or not player.Character:FindFirstChild(getgenv().wzmh.Aimbot.Target_Part) then 
        return Vector3.new(0, 0, 0) 
    end

    if not getgenv().wzmh.Aimbot.Resolver.Enabled then
        return player.Character[getgenv().wzmh.Aimbot.Target_Part].Velocity
    end

    if getgenv().wzmh.Aimbot.Resolver.Method == "Calculate" then
        local part = player.Character[getgenv().wzmh.Aimbot.Target_Part]
        local currentPosition = part.Position
        local deltaTime = RunService.Heartbeat:Wait()
        
        if not PlayerData[player] then
            PlayerData[player] = {
                LastPosition = currentPosition,
                LastTime = tick()
            }
            return part.Velocity
        end

        local displacement = currentPosition - PlayerData[player].LastPosition
        local calculatedVelocity = displacement / deltaTime
        
        PlayerData[player].LastPosition = currentPosition
        PlayerData[player].LastTime = tick()
        
        return calculatedVelocity
    elseif getgenv().wzmh.Aimbot.Resolver.Method == "MoveDirection" then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid and humanoid.MoveDirection and humanoid.WalkSpeed then
            return humanoid.MoveDirection * humanoid.WalkSpeed * get_prediction(player)
        end
        return player.Character[getgenv().wzmh.Aimbot.Target_Part].Velocity
    end
    return Vector3.new(0, 0, 0)
end

    local get_prediction = function(Plr)
        if not Plr or not Plr.Character or not Client or not Client.Character then return 0.1 end
        
        if getgenv().wzmh.Aimbot.Prediction.Auto_Prediction then
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            local humanoidRootPart = Plr.Character:FindFirstChild("HumanoidRootPart")
            local clientHumanoidRootPart = Client.Character:FindFirstChild("HumanoidRootPart")
            
            if humanoidRootPart and clientHumanoidRootPart then
                local distance = (humanoidRootPart.Position - clientHumanoidRootPart.Position).Magnitude
                return 0.1 + (ping / 1000) + (distance / 5000)
            end
        end
        return getgenv().wzmh.Aimbot.Prediction.Amount
    end

    local get_closest_plr_to_center = function()
        if not Camera then return nil end
        local closestDist = getgenv().wzmh.Visuals.FOV.Radius
        local closestPlr = nil
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        for _, v in pairs(Players:GetPlayers()) do
            if v ~= Client and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v.Character.Humanoid.Health > 0 then
                local screenPos, onScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if onScreen then
                    local distFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if distFromCenter < closestDist then
                        closestDist = distFromCenter
                        closestPlr = v
                    end
                end
            end
        end
        return closestPlr
    end
    
    
     make_draggable(LockButton, LockButton)
    make_draggable(MacroButton, MacroButton)

    LockButton.MouseButton1Click:Connect(function()
        Locking = not Locking
        if Locking then
            LockButton.Image = "rbxasset://textures/ui/mouseLock_on@2x.png"
            Plr = get_closest_plr_to_center()
        else
            LockButton.Image = "rbxasset://textures/ui/mouseLock_off@2x.png"
            Plr = nil
        end
    end)

    MacroButton.MouseButton1Click:Connect(function()
        Macroing = not Macroing
        if Macroing then
            MacroButton.ImageTransparency = 0
        else
            MacroButton.ImageTransparency = 0.5
        end
    end)

    RunService.Heartbeat:Connect(function()
    if not Client or not Client.Character then return end
    
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOVCircle.Visible = getgenv().wzmh.Visuals.FOV.Enabled
    FOVCircle.Radius = getgenv().wzmh.Visuals.FOV.Radius and getgenv().wzmh.Visuals.FOV.Radius * 2 or 60
    FOVCircle.Color = getgenv().wzmh.Visuals.FOV.Color
   FOVCircle.Transparency = getgenv().wzmh.Visuals.FOV.Transparency or 1
    
    if Macroing and getgenv().wzmh.Macro.Enabled and Client.Character:FindFirstChild("HumanoidRootPart") and Camera then
        local Look = Camera.CFrame.LookVector
        local Macro = Client.Character.HumanoidRootPart
        if Look and Macro then
            Macro.CFrame = CFrame.new(Macro.Position, Macro.Position + Vector3.new(Look.X, 0, Look.Z))
        end
    end

    if getgenv().wzmh.Visuals.Highlight.Enabled and Locking and Plr then
        Highlight.Adornee = Plr.Character
        Highlight.Enabled = true
        Highlight.FillColor = getgenv().wzmh.Visuals.Highlight.Fill_Color
        Highlight.OutlineColor = getgenv().wzmh.Visuals.Highlight.Outline_Color
        Highlight.FillTransparency = getgenv().wzmh.Visuals.Highlight.Fill_Transparency  
        Highlight.OutlineTransparency = getgenv().wzmh.Visuals.Highlight.Outline_Transparency
    else
        Highlight.Adornee = nil
        Highlight.Enabled = false
    end
end)
      
    RunService.PostSimulation:Connect(function()
   if not Locking or not Plr or not Plr.Character or not workspace.CurrentCamera then return end
   
   local targetPart = Plr.Character:FindFirstChild(getgenv().wzmh.Aimbot.Target_Part)
   if not targetPart then return end
    
   local Position, OnScreen = workspace.CurrentCamera:WorldToScreenPoint(targetPart.Position)
   local Distance = (Vector2.new(Position.X, Position.Y) - Camera.ViewportSize * 0.5).Magnitude
   
   local velocity = resolve_velocity(Plr)
   local prediction = get_prediction(Plr)
   local AimPoint = targetPart.Position + (velocity * prediction)
   
   local Main = CFrame.new(workspace.CurrentCamera.CFrame.p, AimPoint)
   local Smoothing = getgenv().wzmh.Aimbot.Camera.Smoothing
   
   workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(
       Main,
       Smoothing
   )
end)

    local lastAutoAirTime = 0

    RunService.Heartbeat:Connect(function()
        if Locking and Plr and Plr.Character and getgenv().wzmh.Aimbot.Auto_Air.Enabled then
            local humanoid = Plr.Character:FindFirstChild("Humanoid")
            local equipped = Client.Character:FindFirstChildOfClass("Tool")
            
            if humanoid and equipped and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                local currentTime = tick()
                if getgenv().wzmh.Aimbot.Auto_Air.Delay.Enabled then
                    if currentTime - lastAutoAirTime >= getgenv().wzmh.Aimbot.Auto_Air.Delay.Delay_Amount then
                        equipped:Activate()
                        lastAutoAirTime = currentTime
                    end
                else
                    equipped:Activate()



                end
            end
        end
    end)

    getgenv().wzmh.Loaded = true
end
